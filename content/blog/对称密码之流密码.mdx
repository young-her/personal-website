---
title: "对称密码之流密码"
description: "介绍对称密码中的流密码，包括一次一密算法、完善保密性理论以及流密码的基本原理和安全性分析。"
date: "2025-07-07"
author: "y0un92"
tags: ["密码学", "流密码"]
published: true
---


# 前言

**对称密码(Symmetric Cipher)**，也即**私钥密码**。按照是否对明文进行分组可分为**流密码(Stream Cipher)**和**分组密码(Block Cipher)**.本篇文章主要针对流密码进行介绍，资料参考如下：

[现代密码学入门](https://www.bilibili.com/read/readlist/rl252357?spm_id_from=333.1369.opus.module_collection.click) (十分推荐的一个up主)

[完善保密性](https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%96%84%E4%BF%9D%E5%AF%86%E6%80%A7)

[一次性密码本](https://zh.wikipedia.org/wiki/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AF%86%E7%A2%BC%E6%9C%AC)

[流密码](https://zh.wikipedia.org/wiki/%E6%B5%81%E5%AF%86%E7%A0%81)

# 引入

## 一次一密

1917年，**Vernam**发明了叫做**一次一密(One-Time Pad)**的加密算法，这里介绍一个广为人知的版本。一次一密算法有如下特点：

- 明文、密文以及密钥长度都是相同的，即 $|m|=|c|=|k|$
- 密钥是随机产生的
- 顾名思义，密钥只能使用一次
- 加密算法是由明文 $m$ 和密钥 $k$ 逐位异或的
- 解密算法是由密文 $c$ 和密钥 $k$ 逐位异或的

形式化定义如下：

对于 $\forall m\in M,\forall k\in K$，加解密算法如下：
$$
\begin{align}
&加密算法:E(m,k):c=m \oplus k \\
&解密算法:D(c,k):m=c \oplus k
\end{align}
$$

## **安全性分析**

上述介绍说密钥只能使用一次，若用同一密钥加密多个明文呢？对于同一个密钥 $k\in K$ 加密的两个明文 $m_0,m_1$ 得到的密文 $c_0,c_1$，我们可以进行如下运算： $c_0\oplus c_1=m_0\oplus k\oplus m_1 \oplus k=m_0\oplus m_1$，由此可知两个明文里面 $m_0$ 和 $m_1$ 由哪些比特是相等或不等的。虽然看起来并不太严重，但是当传输的数据量非常大的时候，攻击者可以通过像破译古典密码那种对此进行频率分析。

若密钥只使用一次，那么一次一密是**无条件安全(Unconditional Security)**的，**无条件安全**是指攻击者拥有无限的攻击资源和密文来攻击这个加密算法都不可能恢复出明文。**Shannon**曾经提出过**完善保密性(Perfect Secrecy)**的概念，**一个密码算法若满足完善保密性，那么它一定是无条件安全的**。完善保密性的定义如下：

对于明文 $\forall m_0,m_1 \in M(|m_0|=|m_1|)\ ,c\in C$，随机选取 $k_i,k_j\in K$，若满足
$$
Pr[E(m_0,k_i)=c]=Pr[E(m_1,k_j)=c]
$$
这个等式，则说明密码算法是完善保密的。从直观上来说即攻击者拿到密文不能区分是哪一条明文加密而来的。既然明文空间中任意两个明文加密后得到该密文的概率都是一样的，也即一丁点儿信息都没有从密文中泄露出来，那么攻击者自然不可能知道密文对应哪个明文。这里要求**两条明文消息长度是相等**的，主要是考虑有些加密算法的明文长度和密文长度是相等的，那么攻击者通过观察密文长度就知道了明文长度，这样安全性就无法体现了。

这里只是介绍了完善保密性的一个定义，还有一个定义方便计算概率来证明一次一密的完善保密性：

对于明文 $\forall m \in M\ ,c\in C$，随机选取 $k_i,k_j\in K$，若 
$$
Pr[E(m,k_i)=c]=Pr[E(m,k_j)=c]=\frac{|\{k\in K|E(m,k)=c\}|}{|N|}
$$
其中分子表示集合$\{k\in K|E(m,k)=c\}$中元素的个数，$|N|$表示密钥空间中密钥的个数。由于一次一密每次加密都是选用的唯一的密钥，所以上述的概率应该为 $\frac{1}{|N|}$ . 

下述用这个定义以及反证法来证明一次一密是完善保密性的：

引理：在一个对称加密体制内，若它是完善保密性的，则 $|K|\ge |M|$ ，该定理也即**香农定理**. 由于一次一密里 $|K|=|M|$ 所以只需要证明香农定理即可证明一次一密是完善保密性的。

整个思维链是这样的：假设 $|K| < |M|\Longrightarrow \exists m \in M\ ,c\in C，k_i,k_j\in K, \ Pr[E(m,k_i)=c]\neq Pr[E(m,k_j)=c] \Longrightarrow $与完善保密性概念矛盾，故假设不成立。下述主要证明第一步：

对于任意的 $m_0 \in M,k_0 \in K$ 加密得到的密文 $c$，有 
$$
\begin{equation}\label{eqn-1}
Pr[E(m_{0},k)=c]=\frac{|\{k\in K|E(m,k)=c\}|}{|N|}>0
\end{equation}
$$
 定义集合 $S:\{s|s=D(c,k),k\in K\}$，不难得出 $|S|\leq|K|<|M|$(因为 $s$ 集合里面的元素相当于是穷举密钥空间里面的密钥对密文 $c$ 进行解密得到的明文，有可能多个密钥对密文 $c$ 解密得到的明文是相同的，对应着 $|S|<|K|$ 的情况，若 $|S|=|K|$ 则说明每个密钥对密文 $c$ 进行解密得到的明文各不相同)

由于 $|S|<|M|$ ，取 $m_i\in M \ \cap\ m_i \notin S$，则不难得到 $E(m_i,k)\neq c$ (因为如果 $E(m_i,k)= c$ 那么 $m_i\in S$)，故 
$$
\begin{equation}\label{eqn-2}
Pr[E(m_i,k)=c]=0
\end{equation}
$$
结合式 $(3)$ 和 $(4)$ 完善保密性的第一个定义可以得到矛盾，所以假设不成立。由此进一步得出一次一密是具有完全保密性的。

一次一密具有完善保密性，也就是即使攻击者具有无限计算资源也无法从密文获得明文的任何信息。但这只能说明一次一密算法在唯密文攻击下是安全的，不能保证在其它攻击下是安全的。既然一次一密加密算法有如此高的安全性，为什么实际情况中基本不使用呢？因为它太鸡肋了(bushi)，若要传递1MB的信息，就要传递1MB的密钥，既然都可以秘密地传递1MB的密钥了，那为什么不直接传输1MB的明文信息呢。所以在实际情况中，不考虑使用一次一密。而是使用一次一密的改造方案——**流密码**

# 流密码

上述介绍了一次一密之所以鸡肋是因为每次要传输和密文长度一样的密钥，所以不实用。那如何改造呢？一个直观的想法就是用较短的密钥取生成较长的密钥。这里首先引入**随机序列**和**伪随机序列**。

**随机序列：**也称真随机序列，对于 $n$ 位真随机序列，每个比特位产生0或者1的概率相等即为 $\frac{1}{2}$ 且每个比特在产生的时候相互独立。一次一密中密钥的生成即为真随机序列。

**伪随机序列：**若一个序列和真随机序列**不可区分**的话，则可以说明该序列为伪随机序列。**不可区分**的概念之后介绍。

## PRG定义

所以若想要改造一次一密，就要设计一个**伪随机数生成器(PRG,pseudo-random generator)** ，**PRG** 定义如下：

设 $G$ 是一个高效可计算的确定性函数：$G:\{0,1\}^s\rightarrow\{0,1\}^n$ 其中 $s<<n$ ，则 $G$ 是一个 **PRG** 

详细解释一下该定义：

- 高效可计算说明函数 $G$ 输入短密钥 $k$ 之后能够立马输出结果
- 确定性函数说明在输入确定的情况下，函数 $G$ 的输出也是确定的。相同的输入对应着相同的输出。其中输入称为**种子(seed)**，输入的密文空间称为**种子空间**。玩过**MC、terraria**等沙盒游戏的同学可能对种子并不陌生，相同的种子会生成相同的地图。其实这里的种子和伪随机序列里面的种子也是一样的，相同的种子会生成相同的输出。
- 其中 $\{0,1\}^s\rightarrow\{0,1\}^n$ 表示长度为 $s$ 的二进制串生成长度为 $n$ 的二进制串，$s$ 的长度远小于 $n$ 

## 流密码定义

定义了 **PRG** 就可以改造一次一密的定义使其变为流密码：

对于 $\forall m\in M,\forall k\in K$，$G$ 是一个 **PRG**， 加解密算法如下：
$$
\begin{align}
&加密算法:E(m,k):c=G(k) \oplus m \\
&解密算法:D(c,k):m=G(k) \oplus c
\end{align}
$$
其中 $G(k)$ 生成的密钥长度应该和明文密文长度一样。

## 安全性分析

**香农定理**已经证明了当密钥长度小于明文长度时，该密码算法不具有完善保密性，即不具有无条件安全。所以流密码是不具有无条件安全的，于是我们需要定义其他安全模型来阐述流密码的安全性。但是又由于流密码的安全性依赖于**PRG**，若**PRG**能够以假乱真，则说明**PRG**生成的序列和一次一密的密钥是不可区分的，所以这就是流密码为什么安全的依据。
